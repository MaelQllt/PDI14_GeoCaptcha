// Ajout dans le template, après la section "GéoCaptcha généré"
<template>
  <!-- ... reste du code existant ... -->
  
  <div v-if="isModalOpen" class="modal-overlay">
    <div class="fr-container fr-container--fluid fr-container-md">
      <div class="fr-grid-row fr-grid-row--center">
        <div class="fr-col-12 fr-col-md-8 fr-col-lg-6">
          <div class="fr-modal__body">
            <div class="fr-modal__header">
              <button @click="closeModal" aria-controls="modal-6053" title="Fermer" type="button" id="button-6054" class="fr-btn--close fr-btn">Fermer</button>
            </div>

            <div class="fr-modal__content">
              <h1 id="modal-6053-title" class="fr-modal__title">
                <span class="fr-icon-arrow-right-line fr-icon--lg" aria-hidden="true"></span>
                GéoCaptcha généré :
              </h1>
              <p>Voici un GéoCaptcha correspondant à la zone géographique choisie: </p>
              
              <div class="preview-container">
                <div class="map-preview" id="preview-map"></div>
                <div class="circular-overlay" 
                     :style="{ transform: `rotate(${rotationDegrees}deg)` }">
                  <img :src="imageTuile" alt="geocaptcha" v-if="imageTuile" class="circular-image">
                </div>
                <div class="rotation-controls">
                  <button @click="rotateLeft" class="fr-btn fr-btn--sm fr-icon-arrow-left-line"></button>
                  <span>{{ rotationDegrees }}°</span>
                  <button @click="rotateRight" class="fr-btn fr-btn--sm fr-icon-arrow-right-line"></button>
                </div>
              </div>
            </div>
            
            <div class="fr-modal__footer">
              <div class="fr-btns-group fr-btns-group--right fr-btns-group--inline-reverse fr-btns-group--inline-lg fr-btns-group--icon-left">
                <button @click="handleConserver" type="button" id="button-6047" class="accept-btn fr-btn fr-icon-checkbox-circle-line fr-btn--icon-left">Accepter</button>
                <button @click="closeModal" type="button" id="button-6048" class="refuse-btn fr-btn fr-icon-close-circle-line fr-btn--icon-left fr-btn--tertiary">Refuser</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ... reste du code existant ... -->
</template>

<script>
// Ajout des imports nécessaires pour la carte de prévisualisation
import "ol/ol.css";
import Map from "ol/Map.js";
import View from "ol/View.js";
import TileLayer from "ol/layer/Tile.js";
import { fromLonLat } from "ol/proj";
import {XYZ} from 'ol/source';

// Reste des imports existants...

export default {
  name: "OpenLayersMap",
  data() {
    return {
      // Ajout de nouvelles propriétés
      previewMap: null,
      rotationDegrees: 0,
      
      // Propriétés existantes...
      selectedOption: "1",
      selectedDepartement: "",
      departements: [],
      isModalOpen: false,
      isDepartement: false,
      isSuccess: false,
      isRefuse: false,
      successMessage: "",
      latitude: "",
      longitude: "",
      randomDepartement: null,
      latitudePlaceholder: "Entrez une latitude",
      longitudePlaceholder: "Entrez une longitude",
      latitudeMin: null,
      latitudeMax: null,
      longitudeMin: null,
      longitudeMax: null,
      latitudeError: "",
      longitudeError: "",
      zipcode: "",
      mode: "",
      zipcodeError: "",
      modeError: "",
      imageTuile: "",
      map: null,
      draw: null,
      vectorLayer: null,
      source: null,
      selectedShape: "Box",
      boxCoordinates: [],
      randomPoint: null,
      showAlert: false,
    };
  },
  
  // ... autres sections existantes ...
  
  methods: {
    // Nouvelles méthodes pour la rotation et la carte de prévisualisation
    rotateLeft() {
      this.rotationDegrees = (this.rotationDegrees - 15) % 360;
    },
    
    rotateRight() {
      this.rotationDegrees = (this.rotationDegrees + 15) % 360;
    },
    
    initializePreviewMap() {
      // Attendre que le DOM soit prêt
      this.$nextTick(() => {
        const previewMapElement = document.getElementById('preview-map');
        if (!previewMapElement) return;
        
        // Récupération du plan IGN comme fond de carte
        const planIGN = new TileLayer({
          source: new XYZ({
            url: 'https://data.geopf.fr/wmts?' +
                'SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&TILEMATRIXSET=PM' +
                '&LAYER=GEOGRAPHICALGRIDSYSTEMS.PLANIGNV2&STYLE=normal&FORMAT=image/png' +
                '&TILECOL={x}&TILEROW={y}&TILEMATRIX={z}',
            attributions: 'Carte © IGN/Geoplateforme'
          }),
        });
        
        // Créer la carte de prévisualisation
        this.previewMap = new Map({
          layers: [planIGN],
          target: 'preview-map',
          view: new View({
            center: fromLonLat([this.longitude, this.latitude]),
            zoom: 15
          })
        });
      });
    },
    
    // Modification de la méthode showGeoCaptchaTile pour initialiser la carte de prévisualisation
    async showGeoCaptchaTile() {
      // Code existant
      const tileCoords = this.latLonToTile(this.latitude, this.longitude, 15);
      console.log("Coordonnées de la tuile :", tileCoords);

      const data = {
        id: this.generateUniqueId(),
        x: tileCoords.x,
        y: tileCoords.y,
        z: 15,
        zipcode: this.zipcode,
        mode: this.mode,
        ok: "1"
      };
      console.log("Données envoyées à l'API :", data);

      // Cas où le mode est 'plan-sur-plan' -- le changer en 'plan' pour faire fonctionner le mode
      if (data.mode === 'plan-sur-plan') {
        data.mode = 'plan';
      }

      try {
        this.imageTuile = await this.getCaptchaImageTuile(data.mode, data.z, data.x, data.y);
        this.isModalOpen = true;
        
        // Réinitialiser la rotation
        this.rotationDegrees = 0;
        
        // Initialiser la carte de prévisualisation
        this.initializePreviewMap();
      } catch (error) {
        console.error("Erreur :", error);
      }
    },
    
    // Mettre à jour la position du modal pour éviter les problèmes de scrolling
    closeModal() {
      this.isModalOpen = false;
      document.body.style.overflow = 'auto';
      this.isRefuse = true;
      
      // Nettoyer la carte de prévisualisation
      if (this.previewMap) {
        this.previewMap.setTarget(null);
        this.previewMap = null;
      }
      
      setTimeout(() => {
        this.isRefuse = false;
      }, 3000);
    },
    
    // ... reste des méthodes existantes ...
  }
};
</script>

<style scoped>
/* Styles existants... */

/* Nouveaux styles pour la prévisualisation avec overlay circulaire */
.preview-container {
  position: relative;
  width: 100%;
  height: 300px;
  margin: 20px 0;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
}

.map-preview {
  width: 100%;
  height: 100%;
  z-index: 1;
}

.circular-overlay {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 200px;
  height: 200px;
  margin-left: -100px;
  margin-top: -100px;
  border-radius: 50%;
  overflow: hidden;
  z-index: 2;
  border: 3px solid #fff;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
  transition: transform 0.3s ease;
}

.circular-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.rotation-controls {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  align-items: center;
  background: rgba(255, 255, 255, 0.8);
  padding: 5px 10px;
  border-radius: 20px;
  z-index: 3;
}

.rotation-controls span {
  margin: 0 10px;
  font-weight: bold;
}

/* ... autres styles existants ... */
</style>